<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/rental-0.5.5/src/lib.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lib.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../rental/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">//! A macro to generate safe self-referntial structs, plus premade types for common use cases.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # Overview</span>
<span class="doccomment">//! It can sometimes occur in the course of designing an API that it would be convenient, or even necessary, to allow fields within a struct to hold references to other fields within that same struct. Rust&#39;s concept of ownership and borrowing is powerful, but can&#39;t express such a scenario yet.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Creating such a struct manually would require unsafe code to erase lifetime parameters from the field types. Accessing the fields directly would be completely unsafe as a result. This library addresses that issue by allowing access to the internal fields only under carefully controlled circumstances, through closures that are bounded by generic lifetimes to prevent infiltration or exfiltration of any data with an incorrect lifetime. In short, while the struct internally uses unsafe code to store the fields, the interface exposed to the consumer of the struct is completely safe. The implementation of this interface is subtle and verbose, hence the macro to automate the process.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! The API of this crate consists of the [`rental`](macro.rental.html) macro that generates safe self-referential structs, a few example instantiations to demonstrate the API provided by such structs (see [`examples`](examples/index.html)), and a module of premade instantiations to cover common use cases (see [`common`](common/index.html)).</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # Example</span>
<span class="doccomment">//! One instance where this crate is useful is when working with `libloading`. That crate provides a `Library` struct that defines methods to borrow `Symbol`s from it. These symbols are bounded by the lifetime of the library, and are thus considered a borrow. Under normal circumstances, one would be unable to store both the library and the symbols within a single struct, but the macro defined in this crate allows you to define a struct that is capable of storing both simultaneously, like so:</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```rust,ignore</span>
<span class="doccomment">//! rental! {</span>
<span class="doccomment">//!     pub mod rent_libloading {</span>
<span class="doccomment">//!         use libloading;</span>
<span class="doccomment">//! </span>
<span class="doccomment">//!         #[rental(deref_suffix)] // This struct will deref to the Deref::Target of Symbol.</span>
<span class="doccomment">//!         pub struct RentSymbol&lt;S: &#39;static&gt; {</span>
<span class="doccomment">//!             lib: Box&lt;libloading::Library&gt;, // Library is boxed for StableDeref.</span>
<span class="doccomment">//!             sym: libloading::Symbol&lt;&#39;lib, S&gt;, // The &#39;lib lifetime borrows lib.</span>
<span class="doccomment">//!         }</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! fn main() {</span>
<span class="doccomment">//!     let lib = libloading::Library::new(&quot;my_lib.so&quot;).unwrap(); // Open our dylib.</span>
<span class="doccomment">//!     if let Ok(rs) = rent_libloading::RentSymbol::try_new(</span>
<span class="doccomment">//!         Box::new(lib),</span>
<span class="doccomment">//!         |lib| unsafe { lib.get::&lt;extern &quot;C&quot; fn()&gt;(b&quot;my_symbol&quot;) }) // Loading symbols is unsafe.</span>
<span class="doccomment">//!     {</span>
<span class="doccomment">//!         (*rs)(); // Call our function</span>
<span class="doccomment">//!     };</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! In this way we can store both the `Library` and the `Symbol` that borrows it in a single struct. We can even tell our struct to deref to the function pointer itself so we can easily call it. This is legal because the function pointer does not contain any of the special lifetimes introduced by the rental struct in its type signature, which means reborrowing will not expose them to the outside world. As an aside, the `unsafe` block for loading the symbol is necessary because the act of loading a symbol from a dylib is unsafe, and is unrelated to rental.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! **NOTE for Rust 2018:** Relying on implicit crate imports may cause compile errors in code generated by this macro. To avoid this, import the crate manually like so:</span>
<span class="doccomment">//! ```rust,ignore</span>
<span class="doccomment">//! #[macro_use]</span>
<span class="doccomment">//! extern crate rental; </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # Limitations</span>
<span class="doccomment">//! There are a few limitations with the current implementation due to bugs or pending features in rust itself. These will be lifted once the underlying language allows it.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! * Currently, the rental struct itself can only take lifetime parameters under certain conditions. These conditions are difficult to fully describe, but in general, a lifetime param of the rental struct itself must appear &quot;outside&quot; of any special rental lifetimes in the type signatures of the struct fields. To put it another way, replacing the rental lifetimes with `&#39;static` must still produce legal types, otherwise it will not compile. In most situations this is fine, since most of the use cases for this library involve erasing all of the lifetimes anyway, but there&#39;s no reason why the head element of a rental struct shouldn&#39;t be able to take arbitrary lifetime params. This is currently impossible to fully support due to lack of an `&#39;unsafe` lifetime or equivalent feature.</span>
<span class="doccomment">//! * Prefix fields, and the head field if it IS a subrental, must be of the form `Foo&lt;T&gt;` where `Foo` is some `StableDeref` container, or rental will not be able to correctly guess the `Deref::Target` of the type. If you are using a custom type that does not fit this pattern, you can use the `target_ty` attribute on the field to manually specify the target type. If the head field is NOT a subrental, then it may have any form as long as it is `StableDeref`.</span>
<span class="doccomment">//! * Rental structs can only have a maximum of 32 rental lifetimes, including transitive rental lifetimes from subrentals. This limitation is the result of needing to implement a new trait for each rental arity. This limit can be easily increased if necessary.</span>
<span class="doccomment">//! * The references received in the constructor closures don&#39;t currently have their lifetime relationship to eachother expressed in bounds, since HRTB lifetimes do not currently support bounds. This is not a soundness hole, but it does prevent some otherwise valid uses from compiling.</span>


<span class="attribute">#![<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>), <span class="ident">no_std</span>)]</span>

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>)]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">core</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">rental_impl</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">stable_deref_trait</span>;

<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">rental_impl</span>::<span class="kw-2">*</span>;


<span class="doccomment">/// This trait converts any `*_Borrow` or `*_BorrowMut` structs generated by the [`rental`](macro.rental.html) macro into their suffix (most dependent) field.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// When you own a borrow struct, such as in the body of the closure provided to the `rent_all` or `ref_rent_all` methods of a rental struct, you can call `into_suffix()` to discard the borrow struct and obtain the suffix field if you don&#39;t need any of the other fields.</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">IntoSuffix</span> {
	<span class="doccomment">/// Type of the transitive suffix of the borrow struct.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// If the suffix field of the borrow struct is itself a borrow struct of a subrental, then this type is the suffix of that nested borrow struct, recursively.</span>
	<span class="kw">type</span> <span class="ident">Suffix</span>;

	<span class="doccomment">/// Discard the borrow struct and return the transitive suffix field.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// If the suffix field of the borrow struct is itself a borrow struct of a subrental, then this function will return the nested suffix of that borrow struct, recursively.</span>
	<span class="kw">fn</span> <span class="ident">into_suffix</span>(<span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">IntoSuffix</span><span class="op">&gt;</span>::<span class="ident">Suffix</span>;
}


<span class="doccomment">/// An error wrapper returned by the `try_new` method of a rental struct.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This will contain the first error returned by the closure chain, as well as the original head value you passed in so you can do something else with it.</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RentalError</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">H</span><span class="op">&gt;</span> (<span class="kw">pub</span> <span class="ident">E</span>, <span class="kw">pub</span> <span class="ident">H</span>);

<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">RentalResult</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">E</span>, <span class="ident">H</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">RentalError</span><span class="op">&lt;</span><span class="ident">E</span>, <span class="ident">H</span><span class="op">&gt;</span><span class="op">&gt;</span>;


<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">define_rental_traits</span> {
	(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">max_arity</span>:<span class="ident">expr</span>) <span class="op">=</span><span class="op">&gt;</span> {
		<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">unused</span>)]</span>
		<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">__rental_traits</span>)]</span>
		<span class="kw">enum</span> <span class="ident">ProceduralMasqueradeDummyType</span> {
			<span class="ident">Input</span> <span class="op">=</span> (<span class="number">0</span>, <span class="macro">stringify</span><span class="macro">!</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">max_arity</span>)).<span class="number">0</span>
		}
	};
}


<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">__rental_prelude</span> {
	<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">core</span>::<span class="ident">marker</span>::<span class="ident">PhantomData</span>;
	<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">core</span>::<span class="ident">clone</span>::<span class="ident">Clone</span>;
	<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">core</span>::<span class="ident">ops</span>::{<span class="ident">FnOnce</span>, <span class="ident">Deref</span>, <span class="ident">DerefMut</span>, <span class="ident">Drop</span>};
	<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">core</span>::<span class="ident">convert</span>::{<span class="ident">AsRef</span>, <span class="ident">AsMut</span>, <span class="ident">Into</span>};
	<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">core</span>::<span class="ident">borrow</span>::{<span class="ident">Borrow</span>, <span class="ident">BorrowMut</span>};
	<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">core</span>::<span class="ident">mem</span>::<span class="ident">transmute</span>;
	<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">core</span>::<span class="ident">result</span>::<span class="prelude-ty">Result</span>;
	<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">core</span>::<span class="ident">option</span>::<span class="prelude-ty">Option</span>;
	<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">core</span>::<span class="ident">fmt</span>;
	<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">stable_deref_trait</span>::{<span class="ident">StableDeref</span>, <span class="ident">CloneStableDeref</span>};

	<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">super</span>::{<span class="ident">IntoSuffix</span>, <span class="ident">RentalError</span>, <span class="ident">RentalResult</span>};


	<span class="macro">define_rental_traits</span><span class="macro">!</span>(<span class="number">32</span>);


	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">static_assert_stable_deref</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">StableDeref</span><span class="op">&gt;</span>() { }
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">static_assert_mut_stable_deref</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">DerefMut</span> <span class="op">+</span> <span class="ident">StableDeref</span><span class="op">&gt;</span>() { }
}


<span class="doccomment">/// The bedrock of this crate, this macro will generate self-referential structs.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// This macro is invoked in item position. The body parses as valid rust and contains no special syntax. Only certain constructs are allowed, and a few special attributes and lifetimes are recognized.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// To start, the top level item of the macro invocation must be a single module. This module will contain all items that the macro generates and export them to you. Within the module, only three types of items are accepted: `use` statements, type aliases, and struct definitions. The `use` statements and type aliases are passed directly through with no special consideration; the primary concern is the struct definitions.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// First, all struct definitions must have a `#[rental]` or `#[rental_mut]` attribute to indicate that they are self-referential. The `mut` variant indicates that the struct mutably borrows itself, while the normal attribute assumes shared borrows. These attributes also accept certain flags to enable specific features, described below.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// Next, the structs must have named fields (no tuple structs) and they must have at least 2 fields, since a struct with 1 field can&#39;t meaningfully reference itself anyway.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// The order of the fields is significant, as they are declared in order of least to most dependent. The first field, also referred to as the &quot;head&quot; of the struct, contains no self-references, the second field may borrow the first, the third field may borrow the second or first, and so on. The chain of fields after the head is called the &quot;tail&quot;.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// Because rental structs are self-referential, special care is taken to ensure that moving the struct will not invalidate any internal references. This is accomplished by requiring all fields but the last one, collectively known as the &quot;prefix&quot; of the struct, to implement [`StableDeref`](https://crates.io/crates/stable_deref_trait). This is not required for the final field of the struct, known as the &quot;suffix&quot;, since nothing holds a reference to it.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// NOTE: Because of a workaround for a compiler bug, rental might not always correctly determine the `Deref::Target` type of your prefix fields. If you receive type errors when compiling, you can try using the `target_ty` attribute on the field of the struct. Set this attribute equal to a string that names the correct target type (e.g. `#[target_ty = &quot;[u8]&quot;]` for `Vec&lt;u8&gt;`.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// Each field that you declare creates a special lifetime of the same name that can be used by later fields to borrow it. This is how the referential relationships are established in the struct definition.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// This is a all a bit to chew on so far, so let&#39;s stop and take a look at an example:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```rust</span>
<span class="doccomment">/// # #[macro_use] extern crate rental;</span>
<span class="doccomment">/// pub struct Foo { i: i32 }</span>
<span class="doccomment">/// pub struct Bar&lt;&#39;a&gt; { foo: &amp;&#39;a Foo }</span>
<span class="doccomment">/// pub struct Qux&lt;&#39;a: &#39;b, &#39;b&gt; { bar: &amp;&#39;b Bar&lt;&#39;a&gt; }</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// rental! {</span>
<span class="doccomment">///     mod my_rentals {</span>
<span class="doccomment">///         use super::*;</span>
<span class="doccomment">///</span>
<span class="doccomment">///         #[rental]</span>
<span class="doccomment">///         pub struct MyRental {</span>
<span class="doccomment">///             foo: Box&lt;Foo&gt;,</span>
<span class="doccomment">///             bar: Box&lt;Bar&lt;&#39;foo&gt;&gt;,</span>
<span class="doccomment">///             qux: Qux&lt;&#39;foo, &#39;bar&gt;,</span>
<span class="doccomment">///         }</span>
<span class="doccomment">///     }</span>
<span class="doccomment">/// }</span>
<span class="doccomment">/// # fn main () { }</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// Here we see each field use the special lifetimes of the previous fields to establish the borrowing chain.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// In addition to the rental struct itself, two other structs are generated, with `_Borrow` and `_BorrowMut` appended to the original struct name (e.g. `MyRental_Borrow` and `MyRental_BorrowMut`). These structs contain the same fields as the original struct, but are borrows of the originals. These structs are passed into certain closures that you provide to the [`rent_all`](examples/struct.RentRef.html#method.rent_all) suite of methods to allow you access to the struct&#39;s fields. For mutable rentals, these structs will only contain a borrow of the suffix; the other fields will be erased with `PhantomData`.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// # Attribute Flags</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// A `rental` or `rental_mut` attribute accepts various options that affect the code generated by the macro to add certain features if your type supports them. These flags are placed in parens after the attribute, similar to the `cfg` attribute, e.g. `#[rental(debug)]`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ## debug</span>
<span class="doccomment">/// If all the fields of your struct implement `Debug` then you can use the `debug` option on the rental attribute to gain a `Debug` impl on the struct itself. For mutable rental structs, only the suffix field needs to be `Debug`, as it is the only one that will be printed. The prefix fields are mutably borrowed so cannot be accessed while the suffix exists.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ## clone</span>
<span class="doccomment">/// If the prefix fields of your struct impl `CloneStableDeref` (which means clones still deref to the same object), and the suffix field is `Clone`, then your rental struct can be `Clone` as well.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ## deref_suffix / deref_mut_suffix</span>
<span class="doccomment">/// If the suffix field of the struct implements `Deref` or `DerefMut`, you can add a `deref_suffix` or `deref_mut_suffix` argument to the `rental` attribute on the struct. This will generate a `Deref` implementation for the rental struct itself that will deref through the suffix and return the borrow to you, for convenience. Note, however, that this will only be legal if none of the special rental lifetimes appear in the type signature of the deref target. If they do, exposing them to the outside world could result in unsafety, so this is not allowed and such a scenario will not compile.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ## covariant</span>
<span class="doccomment">/// Since the true lifetime of a self-referential field is currently inexpressible in rust, the lifetimes the fields use internally are fake. This means that directly borrowing the fields of the struct would be quite unsafe. However, if we know that the type is covariant over its lifetime parameters, then we can reborrow away the fake rental lifetimes to something concrete and safe. This tag will provide methods that access the fields of the struct directly, while also ensuring that the covariance requirement is met, otherwise the struct will fail to compile. For an exmaple see [`SimpleRefCovariant`](examples/struct.SimpleRefCovariant.html).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ## map_suffix = &quot;T&quot;</span>
<span class="doccomment">/// For rental structs that contain some kind of smart reference as their suffix field, such as a `Ref` or `MutexGuard`, it can be useful to be able to map the reference to another type. This option allows you to do so, given certain conditions. First, your rental struct must have a type parameter in the position that you want to map, such as `Ref&lt;&#39;head, T&gt;` or `MutexGuard&lt;&#39;head, T&gt;`. Second, this type param must ONLY be used in the suffix field. Specify the type parameter you wish to use with `map_suffix = &quot;T&quot;` where `T` is the name of the type param that satisfies these conditions. For an example of the methods this option provides, see [`SimpleRefMap`](examples/struct.SimpleRefMap.html).</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// # Subrentals</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Finally, there is one other capability to discuss. If a rental struct has been defined elsewhere, either in our own crate or in a dependency, we&#39;d like to be able to chain our own rental struct off of it. In this way, we can use another rental struct as a sort of pre-packaged prefix of our own. As a variation on the above example, it would look like this:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```rust</span>
<span class="doccomment">/// # #[macro_use] extern crate rental;</span>
<span class="doccomment">/// pub struct Foo { i: i32 }</span>
<span class="doccomment">/// pub struct Bar&lt;&#39;a&gt; { foo: &amp;&#39;a Foo }</span>
<span class="doccomment">/// pub struct Qux&lt;&#39;a: &#39;b, &#39;b&gt; { bar: &amp;&#39;b Bar&lt;&#39;a&gt; }</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// rental! {</span>
<span class="doccomment">///     mod my_rentals {</span>
<span class="doccomment">///         use super::*;</span>
<span class="doccomment">///</span>
<span class="doccomment">///         #[rental]</span>
<span class="doccomment">///         pub struct OtherRental {</span>
<span class="doccomment">///             foo: Box&lt;Foo&gt;,</span>
<span class="doccomment">///             bar: Bar&lt;&#39;foo&gt;,</span>
<span class="doccomment">///         }</span>
<span class="doccomment">///         </span>
<span class="doccomment">///         #[rental]</span>
<span class="doccomment">///         pub struct MyRental {</span>
<span class="doccomment">///             #[subrental = 2]</span>
<span class="doccomment">///             prefix: Box&lt;OtherRental&gt;,</span>
<span class="doccomment">///             qux: Qux&lt;&#39;prefix_0, &#39;prefix_1&gt;,</span>
<span class="doccomment">///         }</span>
<span class="doccomment">///     }</span>
<span class="doccomment">/// }</span>
<span class="doccomment">/// # fn main () { }</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// The first rental struct is fairly standard, so we&#39;ll focus on the second one. The head field is given a `subrental` attribute and set equal to an integer indicating the arity. The arity of a rental struct is the number of special lifetimes it creates. As can be seen above, the first struct has two fields, neither of which is itself a subrental, so it has an arity of 2. The arity of the second struct would be 3, since it includes the two fields of the first rental as well as one new one. In this way, arity is transitive. So if we used our new struct itself as a subrental of yet another struct, we&#39;d need to declare the field with `subrental = 3`. The special lifetimes created by a subrental are the field name followed by a `_` and a zero-based index. Also note that the suffix field cannot itself be a subrental, only prefix fields.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// This covers the essential capabilities of the macro itself. For details on the API of the structs themselves, see the [`examples`](examples/index.html) module.</span>
<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">rental</span> {
	{
		$(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">attr</span>:<span class="ident">meta</span>]</span>)<span class="op">*</span>
		<span class="kw">mod</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">rental_mod</span>:<span class="ident">ident</span> {
			$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">tt</span>)<span class="op">*</span>
		}
	} <span class="op">=</span><span class="op">&gt;</span> {
		$(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">attr</span>]</span>)<span class="op">*</span>
		<span class="kw">mod</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">rental_mod</span> {
			<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">unused_imports</span>)]</span>
			<span class="kw">use</span> <span class="macro-nonterminal">$</span><span class="kw">crate</span>::<span class="macro-nonterminal">__rental_prelude</span>;

			<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">unused</span>)]</span>
			<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">__rental_structs_and_impls</span>)]</span>
			<span class="kw">enum</span> <span class="ident">ProceduralMasqueradeDummyType</span> {
				<span class="ident">Input</span> <span class="op">=</span> (<span class="number">0</span>, <span class="macro">stringify</span><span class="macro">!</span>($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>)<span class="kw-2">*</span>)).<span class="number">0</span>
			}
		}
	};
	{
		$(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">attr</span>:<span class="ident">meta</span>]</span>)<span class="op">*</span>
		<span class="kw">pub</span> <span class="kw">mod</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">rental_mod</span>:<span class="ident">ident</span> {
			$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">tt</span>)<span class="op">*</span>
		}
	} <span class="op">=</span><span class="op">&gt;</span> {
		$(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">attr</span>]</span>)<span class="op">*</span>
		<span class="kw">pub</span> <span class="kw">mod</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">rental_mod</span> {
			<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">unused_imports</span>)]</span>
			<span class="kw">use</span> <span class="macro-nonterminal">$</span><span class="kw">crate</span>::<span class="macro-nonterminal">__rental_prelude</span>;

			<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">unused</span>)]</span>
			<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">__rental_structs_and_impls</span>)]</span>
			<span class="kw">enum</span> <span class="ident">ProceduralMasqueradeDummyType</span> {
				<span class="ident">Input</span> <span class="op">=</span> (<span class="number">0</span>, <span class="macro">stringify</span><span class="macro">!</span>($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>)<span class="kw-2">*</span>)).<span class="number">0</span>
			}
		}
	};
	{
		$(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">attr</span>:<span class="ident">meta</span>]</span>)<span class="op">*</span>
		<span class="kw">pub</span>($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">vis</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>) <span class="kw">mod</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">rental_mod</span>:<span class="ident">ident</span> {
			$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">tt</span>)<span class="op">*</span>
		}
	} <span class="op">=</span><span class="op">&gt;</span> {
		$(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">attr</span>]</span>)<span class="op">*</span>
		<span class="kw">pub</span>($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">vis</span>)<span class="kw-2">*</span>) <span class="kw">mod</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">rental_mod</span> {
			<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">unused_imports</span>)]</span>
			<span class="kw">use</span> <span class="macro-nonterminal">$</span><span class="kw">crate</span>::<span class="macro-nonterminal">__rental_prelude</span>;

			<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">unused</span>)]</span>
			<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">__rental_structs_and_impls</span>)]</span>
			<span class="kw">enum</span> <span class="ident">ProceduralMasqueradeDummyType</span> {
				<span class="ident">Input</span> <span class="op">=</span> (<span class="number">0</span>, <span class="macro">stringify</span><span class="macro">!</span>($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>)<span class="kw-2">*</span>)).<span class="number">0</span>
			}
		}
	};
}


<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>)]</span>
<span class="macro">rental</span><span class="macro">!</span> {
	<span class="doccomment">/// Example types that demonstrate the API generated by the rental macro.</span>
	<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">examples</span> {
		<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">sync</span>;

		<span class="doccomment">/// The simplest shared rental. The head is a boxed integer, and the suffix is a ref to that integer. This struct demonstrates the basic API that all shared rental structs have. See [`SimpleMut`](struct.SimpleMut.html) for the mutable analog.</span>
		<span class="attribute">#[<span class="ident">rental</span>]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SimpleRef</span> {
			<span class="ident">head</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
			<span class="ident">iref</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;head</span> <span class="ident">i32</span>,
		}

		<span class="doccomment">/// The simplest mutable rental. Mutable rentals have a slightly different API; compare this struct to [`SimpleRef`](struct.SimpleRef.html) for the clearest picture of how they differ.</span>
		<span class="attribute">#[<span class="ident">rental_mut</span>]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SimpleMut</span> {
			<span class="ident">head</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
			<span class="ident">iref</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;head</span> <span class="kw-2">mut</span> <span class="ident">i32</span>,
		}

		<span class="doccomment">/// Identical to [`SimpleRef`](struct.SimpleRef.html), but with the `debug` flag enabled. This will provide a `Debug` impl for the struct as long as all of the fields are `Debug`.</span>
		<span class="attribute">#[<span class="ident">rental</span>(<span class="ident">debug</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SimpleRefDebug</span> {
			<span class="ident">head</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
			<span class="ident">iref</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;head</span> <span class="ident">i32</span>,
		}

		<span class="doccomment">/// Similar to [`SimpleRef`](struct.SimpleRef.html), but with the `clone` flag enabled. This will provide a `Clone` impl for the struct as long as the prefix fields are `CloneStableDeref` and the suffix is `Clone` . Notice that the head is an `Arc`, since a clone of an `Arc` will deref to the same object as the original.</span>
		<span class="attribute">#[<span class="ident">rental</span>(<span class="ident">clone</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SimpleRefClone</span> {
			<span class="ident">head</span>: <span class="ident">sync</span>::<span class="ident">Arc</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
			<span class="ident">iref</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;head</span> <span class="ident">i32</span>,
		}

		<span class="doccomment">/// Identical to [`SimpleRef`](struct.SimpleRef.html), but with the `deref_suffix` flag enabled. This will provide a `Deref` impl for the struct, which will in turn deref the suffix. Notice that this flag also removes the `self` param from all methods, replacing it with an explicit param. This prevents any rental methods from blocking deref.</span>
		<span class="attribute">#[<span class="ident">rental</span>(<span class="ident">deref_suffix</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SimpleRefDeref</span> {
			<span class="ident">head</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
			<span class="ident">iref</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;head</span> <span class="ident">i32</span>,
		}

		<span class="doccomment">/// Identical to [`SimpleMut`](struct.SimpleMut.html), but with the `deref_mut_suffix` flag enabled. This will provide a `DerefMut` impl for the struct, which will in turn deref the suffix.Notice that this flag also removes the `self` param from all methods, replacing it with an explicit param. This prevents any rental methods from blocking deref.</span>
		<span class="attribute">#[<span class="ident">rental_mut</span>(<span class="ident">deref_mut_suffix</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SimpleMutDeref</span> {
			<span class="ident">head</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
			<span class="ident">iref</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;head</span> <span class="kw-2">mut</span> <span class="ident">i32</span>,
		}

		<span class="doccomment">/// Identical to [`SimpleRef`](struct.SimpleRef.html), but with the `covariant` flag enabled. For rental structs where the field types have covariant lifetimes, this will allow you to directly borrow the fields, as they can be safely reborrowed to a shorter lifetime. See the [`all`](struct.SimpleRefCovariant.html#method.all) and [`suffix`](struct.SimpleRefCovariant.html#method.suffix) methods.</span>
		<span class="attribute">#[<span class="ident">rental</span>(<span class="ident">covariant</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SimpleRefCovariant</span> {
			<span class="ident">head</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
			<span class="ident">iref</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;head</span> <span class="ident">i32</span>,
		}

		<span class="doccomment">/// Identical to [`SimpleRef`](struct.SimpleRef.html), but with the `map_suffix` flag enabled. This will allow the type of the suffix to be changed by mapping it to another instantiation of the same struct with the different type param. See the [`map`](struct.SimpleRefMap.html#method.map), [`try_map`](struct.SimpleRefMap.html#method.try_map), and [`try_map_or_drop`](struct.SimpleRefMap.html#method.try_map_or_drop) methods.</span>
		<span class="attribute">#[<span class="ident">rental</span>(<span class="ident">map_suffix</span> <span class="op">=</span> <span class="string">&quot;T&quot;</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SimpleRefMap</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> {
			<span class="ident">head</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
			<span class="ident">iref</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;head</span> <span class="ident">T</span>,
		}
	}
}


<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>)]</span>
<span class="macro">rental</span><span class="macro">!</span> {
	<span class="doccomment">/// Premade types for the most common use cases.</span>
	<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">common</span> {
		<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">ops</span>::<span class="ident">DerefMut</span>;
		<span class="kw">use</span> <span class="ident">stable_deref_trait</span>::<span class="ident">StableDeref</span>;
		<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">cell</span>;
		<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">sync</span>;

		<span class="doccomment">/// Stores an owner and a shared reference in the same struct.</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// ```rust</span>
		<span class="doccomment">/// # extern crate rental;</span>
		<span class="doccomment">/// # use rental::common::RentRef;</span>
		<span class="doccomment">/// # fn main() {</span>
		<span class="doccomment">/// let r = RentRef::new(Box::new(5), |i| &amp;*i);</span>
		<span class="doccomment">/// assert_eq!(*r, RentRef::rent(&amp;r, |iref| **iref));</span>
		<span class="doccomment">/// # }</span>
		<span class="doccomment">/// ```</span>
		<span class="attribute">#[<span class="ident">rental</span>(<span class="ident">debug</span>, <span class="ident">clone</span>, <span class="ident">deref_suffix</span>, <span class="ident">covariant</span>, <span class="ident">map_suffix</span> <span class="op">=</span> <span class="string">&quot;T&quot;</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RentRef</span><span class="op">&lt;</span><span class="ident">H</span>: <span class="lifetime">&#39;static</span> <span class="op">+</span> <span class="ident">StableDeref</span>, <span class="ident">T</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> {
			<span class="ident">head</span>: <span class="ident">H</span>,
			<span class="ident">suffix</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;head</span> <span class="ident">T</span>,
		}

		<span class="doccomment">/// Stores an owner and a mutable reference in the same struct.</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// ```rust</span>
		<span class="doccomment">/// # extern crate rental;</span>
		<span class="doccomment">/// # use rental::common::RentMut;</span>
		<span class="doccomment">/// # fn main() {</span>
		<span class="doccomment">/// let mut r = RentMut::new(Box::new(5), |i| &amp;mut *i);</span>
		<span class="doccomment">/// *r = 12;</span>
		<span class="doccomment">/// assert_eq!(12, RentMut::rent(&amp;mut r, |iref| **iref));</span>
		<span class="doccomment">/// # }</span>
		<span class="doccomment">/// ```</span>
		<span class="attribute">#[<span class="ident">rental_mut</span>(<span class="ident">debug</span>, <span class="ident">deref_mut_suffix</span>, <span class="ident">covariant</span>, <span class="ident">map_suffix</span> <span class="op">=</span> <span class="string">&quot;T&quot;</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RentMut</span><span class="op">&lt;</span><span class="ident">H</span>: <span class="lifetime">&#39;static</span> <span class="op">+</span> <span class="ident">StableDeref</span> <span class="op">+</span> <span class="ident">DerefMut</span>, <span class="ident">T</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> {
			<span class="ident">head</span>: <span class="ident">H</span>,
			<span class="ident">suffix</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;head</span> <span class="kw-2">mut</span> <span class="ident">T</span>,
		}

		<span class="doccomment">/// Stores a `RefCell` and a `Ref` in the same struct.</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// ```rust</span>
		<span class="doccomment">/// # extern crate rental;</span>
		<span class="doccomment">/// # use rental::common::RentRefCell;</span>
		<span class="doccomment">/// # fn main() {</span>
		<span class="doccomment">/// use std::cell;</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// let r = RentRefCell::new(Box::new(cell::RefCell::new(5)), |c| c.borrow());</span>
		<span class="doccomment">/// assert_eq!(*r, RentRefCell::rent(&amp;r, |c| **c));</span>
		<span class="doccomment">/// # }</span>
		<span class="doccomment">/// ```</span>
		<span class="attribute">#[<span class="ident">rental</span>(<span class="ident">debug</span>, <span class="ident">clone</span>, <span class="ident">deref_suffix</span>, <span class="ident">covariant</span>, <span class="ident">map_suffix</span> <span class="op">=</span> <span class="string">&quot;T&quot;</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RentRefCell</span><span class="op">&lt;</span><span class="ident">H</span>: <span class="lifetime">&#39;static</span> <span class="op">+</span> <span class="ident">StableDeref</span>, <span class="ident">T</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> {
			<span class="ident">head</span>: <span class="ident">H</span>,
			<span class="ident">suffix</span>: <span class="ident">cell</span>::<span class="ident">Ref</span><span class="op">&lt;</span><span class="lifetime">&#39;head</span>, <span class="ident">T</span><span class="op">&gt;</span>,
		}

		<span class="doccomment">/// Stores a `RefCell` and a `RefMut` in the same struct.</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// ```rust</span>
		<span class="doccomment">/// # extern crate rental;</span>
		<span class="doccomment">/// # use rental::common::RentRefCellMut;</span>
		<span class="doccomment">/// # fn main() {</span>
		<span class="doccomment">/// use std::cell;</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// let mut r = RentRefCellMut::new(Box::new(cell::RefCell::new(5)), |c| c.borrow_mut());</span>
		<span class="doccomment">/// *r = 12;</span>
		<span class="doccomment">/// assert_eq!(12, RentRefCellMut::rent(&amp;r, |c| **c));</span>
		<span class="doccomment">/// # }</span>
		<span class="doccomment">/// ```</span>
		<span class="attribute">#[<span class="ident">rental_mut</span>(<span class="ident">debug</span>, <span class="ident">deref_mut_suffix</span>, <span class="ident">covariant</span>, <span class="ident">map_suffix</span> <span class="op">=</span> <span class="string">&quot;T&quot;</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RentRefCellMut</span><span class="op">&lt;</span><span class="ident">H</span>: <span class="lifetime">&#39;static</span> <span class="op">+</span> <span class="ident">StableDeref</span> <span class="op">+</span> <span class="ident">DerefMut</span>, <span class="ident">T</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> {
			<span class="ident">head</span>: <span class="ident">H</span>,
			<span class="ident">suffix</span>: <span class="ident">cell</span>::<span class="ident">RefMut</span><span class="op">&lt;</span><span class="lifetime">&#39;head</span>, <span class="ident">T</span><span class="op">&gt;</span>,
		}


		<span class="doccomment">/// Stores a `Mutex` and a `MutexGuard` in the same struct.</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// ```rust</span>
		<span class="doccomment">/// # extern crate rental;</span>
		<span class="doccomment">/// # use rental::common::RentMutex;</span>
		<span class="doccomment">/// # fn main() {</span>
		<span class="doccomment">/// use std::sync;</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// let mut r = RentMutex::new(Box::new(sync::Mutex::new(5)), |c| c.lock().unwrap());</span>
		<span class="doccomment">/// *r = 12;</span>
		<span class="doccomment">/// assert_eq!(12, RentMutex::rent(&amp;r, |c| **c));</span>
		<span class="doccomment">/// # }</span>
		<span class="doccomment">/// ```</span>
		<span class="attribute">#[<span class="ident">rental</span>(<span class="ident">debug</span>, <span class="ident">clone</span>, <span class="ident">deref_mut_suffix</span>, <span class="ident">covariant</span>, <span class="ident">map_suffix</span> <span class="op">=</span> <span class="string">&quot;T&quot;</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RentMutex</span><span class="op">&lt;</span><span class="ident">H</span>: <span class="lifetime">&#39;static</span> <span class="op">+</span> <span class="ident">StableDeref</span> <span class="op">+</span> <span class="ident">DerefMut</span>, <span class="ident">T</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> {
			<span class="ident">head</span>: <span class="ident">H</span>,
			<span class="ident">suffix</span>: <span class="ident">sync</span>::<span class="ident">MutexGuard</span><span class="op">&lt;</span><span class="lifetime">&#39;head</span>, <span class="ident">T</span><span class="op">&gt;</span>,
		}

		<span class="doccomment">/// Stores an `RwLock` and an `RwLockReadGuard` in the same struct.</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// ```rust</span>
		<span class="doccomment">/// # extern crate rental;</span>
		<span class="doccomment">/// # use rental::common::RentRwLock;</span>
		<span class="doccomment">/// # fn main() {</span>
		<span class="doccomment">/// use std::sync;</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// let r = RentRwLock::new(Box::new(sync::RwLock::new(5)), |c| c.read().unwrap());</span>
		<span class="doccomment">/// assert_eq!(*r, RentRwLock::rent(&amp;r, |c| **c));</span>
		<span class="doccomment">/// # }</span>
		<span class="doccomment">/// ```</span>
		<span class="attribute">#[<span class="ident">rental</span>(<span class="ident">debug</span>, <span class="ident">clone</span>, <span class="ident">deref_suffix</span>, <span class="ident">covariant</span>, <span class="ident">map_suffix</span> <span class="op">=</span> <span class="string">&quot;T&quot;</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RentRwLock</span><span class="op">&lt;</span><span class="ident">H</span>: <span class="lifetime">&#39;static</span> <span class="op">+</span> <span class="ident">StableDeref</span>, <span class="ident">T</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> {
			<span class="ident">head</span>: <span class="ident">H</span>,
			<span class="ident">suffix</span>: <span class="ident">sync</span>::<span class="ident">RwLockReadGuard</span><span class="op">&lt;</span><span class="lifetime">&#39;head</span>, <span class="ident">T</span><span class="op">&gt;</span>,
		}

		<span class="doccomment">/// Stores an `RwLock` and an `RwLockWriteGuard` in the same struct.</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// ```rust</span>
		<span class="doccomment">/// # extern crate rental;</span>
		<span class="doccomment">/// # use rental::common::RentRwLockMut;</span>
		<span class="doccomment">/// # fn main() {</span>
		<span class="doccomment">/// use std::sync;</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// let mut r = RentRwLockMut::new(Box::new(sync::RwLock::new(5)), |c| c.write().unwrap());</span>
		<span class="doccomment">/// *r = 12;</span>
		<span class="doccomment">/// assert_eq!(12, RentRwLockMut::rent(&amp;r, |c| **c));</span>
		<span class="doccomment">/// # }</span>
		<span class="doccomment">/// ```</span>
		<span class="attribute">#[<span class="ident">rental</span>(<span class="ident">debug</span>, <span class="ident">clone</span>, <span class="ident">deref_mut_suffix</span>, <span class="ident">covariant</span>, <span class="ident">map_suffix</span> <span class="op">=</span> <span class="string">&quot;T&quot;</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RentRwLockMut</span><span class="op">&lt;</span><span class="ident">H</span>: <span class="lifetime">&#39;static</span> <span class="op">+</span> <span class="ident">StableDeref</span>, <span class="ident">T</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> {
			<span class="ident">head</span>: <span class="ident">H</span>,
			<span class="ident">suffix</span>: <span class="ident">sync</span>::<span class="ident">RwLockWriteGuard</span><span class="op">&lt;</span><span class="lifetime">&#39;head</span>, <span class="ident">T</span><span class="op">&gt;</span>,
		}
	}
}


</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "rental";</script><script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script></body></html>